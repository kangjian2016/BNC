#' @title {Simulated dataset generator}
#' @aliases simulatedDatasetGenerator
#' @name SimulatedDatasetGenerator
#' @usage
#' simulatedDatasetGenerator(net=NULL,nnode=NULL,maxpernull=0.7,class.label=NULL,
#' missloc=NULL,missing=FALSE,missrate=0.1,nonmiss.hub.maxedges=7,
#' maxnsteps.merge.communties=1000,dist=c("norm","gamma","lognorm"),
#' plot=c(TRUE,FALSE),nbin=c(20,20,20),rng=1024)
#' @description The function used to generating simulated datasets. See details in simulation studies
#' @param net The binary adjacent matrix representing the gene network configuration. The element at (i,j) location of value 0 indicating "gene i and gene j are connected" or "gene i and gene j are not directly connected". If not given, generate a scale-free graph according to the Barabasi-Albert model by applying the BA algorithm in the igraph package.
#' @param nnode An integer. Total number of gene nodes in network.
#' @param maxpernull A float number. The highest tolerable proportion of null genes in the network. Used when class.label is not given and it needs to be generated during the merging process. The default is 0.7
#' @param class.label A vector of length equals the total number of gene nodes. Each element in the vector represents the class label of each gene regulation type (can be -1, 0, 1). If it is not given, the class labels are defined based on the fast greedy community detection algorithm. Then the communities are merged into three class each one at a time based on their number of between-community-edges. Highly connected communities are merged into one first. Then the largest communities are assigned a class label of 0 to represent the null genes. The up/down regulated class are assigned randomly afterwards
#' @param missloc A vector. It gives the location of the test statistics vector that is not been observed. The default is NULL
#' @param missing Logical. If TRUE, the missing locations are generated based on the missing rate. The default is FALSE
#' @param missrate A number between (0,1). The missing rate is defined as the proportion of gene nodes without observed test statistics. We do not recommend users to set this rate above 20\% because it is less likely to be the real data based on our own biological knowledge
#' @param nonmiss.hub.maxedges An integer. Based on our knowledge, a  hub gene (a gene with a larger number of neighboring edges) is less likely to be a missing gene node. This is the upper bound where only genes with less than the nonmiss.hub.maxedges neighbors can be assigned as missing genes in the simulation studies. The default is 7
#' @param maxnsteps.merge.communties An integer. It is the maximum number of steps used for merging the smaller communities in the merging process. The default is 1000
#' @param dist A string. The distribution of differentially expressed genes (non-null genes). It can be one of the following: "norm", "gamma" or "lognorm". See details in the simulation design table
#' @param plot Logical. The default is TRUE. Whether to plot the histogram of test statistics being generated or not in the end
#' @param nbin A vector of length 3. The default is c(5,20,5). The number of bins used for plotting the histogram for each of the class: class label = -1, 0, 1
#' @param rng Random seed, the default is 1024
#' @return A list contains
#' \item{testcov}{The test statistics, missing observations are coded as NA if any}
#' \item{testcov.fullobs}{The test statistics when all the observations are fully observed}
#' \item{class.label}{The vector stores the class label for genes. The z values in the paper}
#' \item{net}{The simulated network, represented as a binary adjacency matrix 1/0}
#' @details The function is used for simulating the test statistics:
#' \itemize{
#' \item network is given or generated by Barabasi-Albert algorithm in igraph package.
#' \item class indicators is given or generated based on fast.greedy community detection algorithm.
#' \item test statistics, currently support three simulation scenario: c("norm","gamma","lognorm")
#' }
#' @examples
#' \dontrun{
#' ## The simulation settings based on real gene network. (takes time)
#' data(geneNetwork)
#' data(classLabels)
#' data(missingLocations)
#' simdata=simulatedDatasetGenerator(net=geneNetwork,class.label=classLabels,
#' missloc=missingLocations,missing=TRUE,dist="norm",plot=TRUE,nbin=c(20,20,20),rng=1024)
#' str(simdata)
#' ## A toy example
#' simdata=simulatedDatasetGenerator(nnode=100,missing=TRUE,missrate=0.1,dist="norm",
#' plot=TRUE,nbin=c(20,20,10),rng=1024)
#' str(simdata)
#' }
#' @export
simulatedDatasetGenerator=function(net=NULL,nnode=NULL,maxpernull=0.7,class.label=NULL,missloc=NULL,missing=FALSE,missrate=0.1,nonmiss.hub.maxedges=7,maxnsteps.merge.communties=1000,dist=c("norm","gamma","lognorm"),plot=c(TRUE,FALSE),nbin=c(20,20,20),rng=1024){
  set.seed(rng)
  if(is.null(net)){
    if(is.null(nnode)){
      stop("Please input an integer number as the total number of genes in the network")
    }else{
      g=igraph::sample_pa(nnode,directed=FALSE)
      net=as.matrix(igraph::get.adjacency(g))
      diag(net)=0
    }
  }
  if(is.null(class.label)){
    g=igraph::graph.adjacency(net, mode="undirected")
    graph.com=igraph::fastgreedy.community(g)
    members=table(graph.com$membership)
    memberids=graph.com$membership
    idnames=as.numeric(names(members))
    if(length(members)<3){
      stop("Too simplified case, please consider another simulation setting")
    }else{
      ng=length(members)
      while(ng>3){
        ### calculate betweenness matrix:
        btmat=matrix(0,ng,ng)
        for(i in 1:(ng-1)){
          ptloc.i=which(memberids==idnames[i])
          btmat[i,(i+1):ng]=sapply((i+1):ng,function(j){
            pt.loc.j=which(memberids==idnames[j])
            sum(net[ptloc.i,pt.loc.j])
          })
        }
        max.memberid=which(btmat==max(btmat),arr.ind=TRUE)
        pt.a.merge=apply(max.memberid,1,function(x){sum(members[x])})
        gid=max.memberid[which(pt.a.merge==max(pt.a.merge))[1],]
        ## update
        gid.change=gid[which((gid)==max(gid))]
        gid.stay=gid[which((gid)==min(gid))]

        tmp.memberids=memberids
        tmp.memberids[which(tmp.memberids==idnames[gid.change])]=idnames[gid.stay]
        tmp.members=table(tmp.memberids)

        if(length(tmp.members)<3 | max(tmp.members)> (maxpernull*nnode)){
          break;
        }else{
          memberids=tmp.memberids
          members=tmp.members
          ng=length(members)
          idnames=as.numeric(names(members))
        }
        # memberids[which(memberids==idnames[gid.change])]=idnames[gid.stay]
        # members=table(memberids)
        # ng=length(members)
        # idnames=as.numeric(names(members))
        # print(ng)
      }

      g0=idnames[which(members==max(members))]
      class.label=rep(NA,length=nnode)
      class.label[which(memberids==g0)]=0
      ng=length(members)-1
      sigloc=which(is.na(class.label))

      subnet=net[sigloc,sigloc]
      memberids=memberids[sigloc]
      members=table(memberids)
      idnames=as.numeric(names(members))

      ### random assign labels as long as balanced.
      g1=sample(idnames,1)
      n1=members[as.character(g1)]
      while(n1<(length(sigloc)/2)){
        l=sample(setdiff(idnames,g1),1)
        g1=c(g1,l)
        n1=n1+members[as.character(l)]
      }
      class.label[which(memberids%in%g1)]=1
      class.label[is.na(class.label)]=-1
    }
  }

  simRDat=vector(length=length(class.label))
  npt=table(class.label)
  if(dist=="norm"){
    simRDat[which(class.label==-1)]=stats::rnorm(npt[1],mean=-0.8,sd=0.2)
    simRDat[which(class.label==0)]=stats::rnorm(npt[2],mean=0,sd=0.2)
    simRDat[which(class.label==1)]=stats::rnorm(npt[3],mean=0.8,sd=0.2)
  }else if(dist=="gamma"){
    simRDat[which(class.label==0)]=stats::rnorm(npt[2],mean=0,sd=0.4)
    y=stats::rgamma(10*nnode,shape=2,scale=0.5)
    simRDat[which(class.label==-1)]=sample(y[which(y<(0.1+1.9))],size=npt[1],replace=FALSE)-1.9
    y=stats::rgamma(10*nnode,shape=2,scale=0.3)
    simRDat[which(class.label==1)]=-sample(y[which(y<(0.1+1.7))],size=npt[3],replace=FALSE)+1.7
  }else if(dist=="lognorm"){
    simRDat[which(class.label==0)]=stats::rnorm(npt[2],mean=0,sd=0.4)
    y=stats::rlnorm(10*nnode,meanlog=0,sdlog=1)
    simRDat[which(class.label==-1)]=sample(y[which(y<(0.1+1.9))],size=npt[1],replace=FALSE)-1.9
    y=stats::rlnorm(10*nnode,meanlog=0,sdlog=0.4)
    simRDat[which(class.label==1)]=-sample(y[which(y<(0.1+2.2))],size=npt[3],replace=FALSE)+2.2
  }

  if(plot){
    p1=graphics::hist(simRDat[which(class.label==-1)],breaks=nbin[1])
    p2=graphics::hist(simRDat[which(class.label==0)],breaks=nbin[2])
    p3=graphics::hist(simRDat[which(class.label==1)],breaks=nbin[3])
    ll=max(p1$counts,p2$counts,p3$counts)
    plot(p1, col=grDevices::rgb(0,0,1,1/4), xlim=range(simRDat),ylim=c(0,ll),main=paste0("Simulated ",dist," Cases"),xlab="Test Statistics")
    plot(p2, col=grDevices::rgb(1,0,0,1/4), xlim=range(simRDat),ylim=c(0,ll), add=TRUE)
    plot(p3, col=grDevices::rgb(0,1,0,1/4), xlim=range(simRDat),ylim=c(0,ll), add=TRUE)
    graphics::legend("topleft",c("down-regulated","null","up-regulated"),fill=c(grDevices::rgb(0,0,1,1/4),grDevices::rgb(1,0,0,1/4),grDevices::rgb(0,1,0,1/4)),bty = 'n',cex=1)
  }

  if(is.null(missloc) & missing){
    misloc=which(rowSums(net)<nonmiss.hub.maxedges)
    nmis=round(missrate*nnode)
    if(length(misloc)<round(missrate*nnode)){
      stop("Change missrate or nonmiss.hub.maxedges")
    }else{
      missloc=sample(misloc,size=nmis,replace=FALSE)
    }
  }

  if(missing){
    simRDatFull=simRDat
    simRDat[missloc]=NA
  }else{
    simRDatFull=NULL
  }


  res=list(testcov=simRDat,testcov.fullobs=simRDatFull,class.label=class.label,net=net)
  return(res)
}
